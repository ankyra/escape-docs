## Quickstart

At its core Escape provides abstractions to work with _units of deployments_. A
_unit of deployment_ is a collection of files, plus a bit of metadata to tell
Escape what can be done with it. Based on the metadata Escape knows how to
deploy, test and destroy the unit.

Metadata doesn't have to be written by hand, but can be compiled from an
_Escape plan_. The smallest Escape plan looks like this:

```
name: my-project/my-deployment-unit
version: 1.0
```

(Pro-tip: A documented, but otherwise fairly similar Escape plan, can be
generated by running `escape plan init -n my-deployment-unit`. You can also
format existing plans in this manner by running `escape plan fmt`)

### Build and test

The life cycle of almost every unit starts with a build step. This step is
generally only run on developer's workstations and CI servers. 

```
$ escape build
```

Our almost empty Escape plan doesn't define a build step however, 
but we can add one:

```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
```

Next we might wanna test our build:

```
$ escape test
```

And again we can define a field:

```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
test: test_my_thing.sh
```

### Deploy and smoke

Once a unit has been built we want to be able to deploy it into an
_environment_.

```
$ escape deploy
```

Same thing again. And let's also add a field for `escape smoke` to run our
smoke tests.


```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
test: test_my_thing.sh
deploy: deploy_my_thing.sh
smoke: smoke_test_my_thing.sh
```


### Package

So far, so good. We're just running some tasks. Nothing fancy, but let's
package it all up into a distributable unit:

```
$ escape package
```

This takes all the files referenced in the Escape plan and adds them into an
archive, combined with the compiled metadata. We can include more files by glob
patterns:

```
name: my-project/my-deployment-unit
version: 1.0
build: build_my_thing.sh
test: test_my_thing.sh
deploy: deploy_my_thing.sh
smoke: smoke_test_my_thing.sh

includes:
- src/*.src
- assets/
- README

```

And then package again (we need to use the `-f` flag, because we already
created an archive for this version in the previous command)

```
$ escape package -f
```

### Push

Once happy we can push it to a server (note: the client points to the Ankyra
registry by default, which doesn't allow public writes, but you can run a
stand-alone registry).

```
$ escape push
```

This will make `my-project/my-deployment-unit-v1.0` available in the registry
and it will effectively freeze our version, because we can't upload the same
version twice. Our fellow engineers can now deploy this release by running:

```
$ escape deploy my-project/my-deployment-unit-v1.0
```

### Release

Instead of running all the steps one by one we can also use the `escape
release` command, which is generally preferable in CI settings.

```
$ escape release
```

This will run the build, test, deploy, smoke, destroy, package and push steps
in succession to make sure the unit is working end-to-end (although parts can
be skipped see `escape release --help`)

### Auto-versioning

It's a bit annoying to have to change the version field every time you do a
build, but at the same time having immutable releases is valuable. Wouldn't it
be nice if we could automatically pick a new version? Yes.

```
name: my-project/my-deployment-unit
version: 1.0.@
build: build_my_thing.sh
```

This will first build `1.0.0`, but once that's been released it will take
`1.0.1`, `1.0.2`, `1.0.3`, ...  If we want to work on a new minor version, we
can change the field manually to:

```
name: my-project/my-deployment-unit
version: 1.1.@
build: build_my_thing.sh
```

And then the next version will be `1.1.0`, `1.1.1`, ... Following such a scheme
strikes a reasonable balance between having meaningful versions vs. an annoying
release process.

### Inputs and outputs

It's easy to take a string input

```
name: my-project/my-deployment-unit
version: 0.0.@
inputs:
- my_variable
```

Or in the longer form:

```
name: my-project/my-deployment-unit
version: 0.0.@
inputs:
- id: my_variable
  type: string
```

We can also specify the types `integer`, `bool` and `list`.

```
name: my-project/my-deployment-unit
version: 0.0.@
inputs:
- id: my_variable
  type: bool
  default: true
  description: "Is this a boolean?"
  friendly: "My Variable"
```

We can tell it to pick a value out of a list:

```
name: my-project/my-deployment-unit
version: 0.0.@
inputs:
- id: my_variable
  type: string
  items:
  - choice number 1
  - choice number 2
```

And calculate a default value:


### State management

### Errands

### Dependencies

```
name: my-project/my-deployment-unit
version: 0.0.@
depends:
- stdlib-latest
```

A unit can use its dependencies' outputs as its own inputs.

For more information on the scripting language see https://github.com/ankyra/escape-core/

### Providers and Consumers


```
name: my-project/my-provider
version: 0.0.@
provides:
- a-provider

outputs:
- id: test_output
  default: hello world
```

```
name: my-project/my-consumer
version: 0.0.@
consumes:
- a-provider

inputs:
- id: test_input
  default: $a-provider.outputs.test_output
```


### Extensions

```
name: my-project/my-deployment-unit
version: 0.0.@
extends:
- extension-docker-latest
```

### Templates

```
name: my-project/my-deployment-unit
version: 0.0.@
inputs:
- my_variable

templates:
- file: output.txt.tpl
```

```
name: my-project/my-deployment-unit
version: 0.0.@
inputs:
- my_variable

templates:
- file: output.txt.tpl
  mapping:
    input: $this.inputs.my_variable
    input2: "yo"
```

